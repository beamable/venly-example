using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.VenlyFederation.Exceptions;
using Beamable.VenlyFederation.Features.Contracts;
using Beamable.VenlyFederation.Features.Transactions;
using Beamable.VenlyFederation.Features.Transactions.Models;
using Beamable.VenlyFederation.Features.VenlyApi;
using Beamable.VenlyFederation.Features.Wallet;
using Venly.Models.Wallet;

namespace Beamable.VenlyFederation.Features.Transfers;

public class TransferService : IService
{
    private readonly VenlyApiService _venlyApiService;
    private readonly Configuration _configuration;
    private readonly InventoryApi _inventoryApi;
    private readonly ContractService _contractService;
    private readonly WalletService _walletService;
    private readonly TransactionManager _transactionManager;

    public TransferService(VenlyApiService venlyApiService, Configuration configuration, InventoryApi inventoryApi, ContractService contractService, WalletService walletService, TransactionManager transactionManager)
    {
        _venlyApiService = venlyApiService;
        _configuration = configuration;
        _inventoryApi = inventoryApi;
        _contractService = contractService;
        _walletService = walletService;
        _transactionManager = transactionManager;
    }
    
    public async Task TransferItemToPlayer(string transaction, int itemId, VyWalletDto sourceWallet, long destinationPlayerId, long senderPlayerId)
    {
        var sourceItem = await GetSourceItem(itemId, senderPlayerId);

        var contract = await _contractService.GetOrCreateDefaultContract();

        var destinationWallet = await _walletService.GetOrCreateWallet(destinationPlayerId.ToString());

        var transferResponse = await _venlyApiService.Transfer(_configuration.WalletPin.Value, new VyTransactionMultiTokenTransferRequest
        {
            Chain = await _configuration.GetChain(),
            WalletId = sourceWallet.Id,
            FromAddress = sourceWallet.Address,
            ToAddress = destinationWallet.Address,
            Amount = 1,
            TokenId = int.Parse(sourceItem.proxyId),
            TokenAddress = contract.Address
        });

        var chainTransactions = new[] { transferResponse.TransactionHash };
        
        await _transactionManager.SaveChainTransactions(transaction, chainTransactions);
        _ = _transactionManager.PoolChainTransactions(transaction, chainTransactions, new List<AffectedPlayer>
        {
            new(senderPlayerId, sourceWallet.Address),
            new(destinationPlayerId, destinationWallet.Address)
        });
    }
    
    public async Task TransferItemExternal(string transaction, int itemId, VyWalletDto sourceWallet, string destinationWallet, long senderPlayerId)
    {
        var sourceItem = await GetSourceItem(itemId, senderPlayerId);

        var contract = await _contractService.GetOrCreateDefaultContract();

        var transferResponse = await _venlyApiService.Transfer(_configuration.WalletPin.Value, new VyTransactionMultiTokenTransferRequest
        {
            Chain = await _configuration.GetChain(),
            WalletId = sourceWallet.Id,
            FromAddress = sourceWallet.Address,
            ToAddress = destinationWallet,
            Amount = 1,
            TokenId = int.Parse(sourceItem.proxyId),
            TokenAddress = contract.Address
        });

        var chainTransactions = new[] { transferResponse.TransactionHash };
        
        await _transactionManager.SaveChainTransactions(transaction, chainTransactions);
        _ = _transactionManager.PoolChainTransactions(transaction, chainTransactions, new List<AffectedPlayer>
        {
            new(senderPlayerId, sourceWallet.Address)
        });
    }

    private async Task<Item> GetSourceItem(int itemId, long senderPlayerId)
    {
        var senderInventory = await _inventoryApi.ObjectGet(senderPlayerId);
        var senderItems = senderInventory.items
            .SelectMany(x => x.items)
            .ToList();

        var sourceItem = senderItems.FirstOrDefault(x => x.id == itemId && x.proxyId.HasValue);
        if (sourceItem is null)
            throw new InvalidRequestException($"Player doesn't own the federated item {itemId}");
        return sourceItem;
    }
}